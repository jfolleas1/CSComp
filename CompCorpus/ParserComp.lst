
// ==========================================================================
//  GPPG error listing for yacc source file <ParserComp.y - 16/06/2017 13:28:16>
// ==========================================================================
//  Version:  1.5.2
//  Machine:  FIDF3675368
//  DateTime: 16/06/2017 13:28:37
//  UserName: j.folleas
// ==========================================================================


%using CompCorpus.RunTime;
%using CompCorpus.RunTime.declaration;

%namespace CompCorpus.Analyzer
%output=Analyzer\ParserComp.cs

%{
    
    public Montage montage = new Montage();

%}

%start montage

%union {
        public string String;
        public long Integer;
        public double Float;
		public Affectation affectation;
		public AbstractExpression expression;
		public Variable constante;
		public VariableId variable ;
		public Declaration declaration ;
		public List<Declaration> listDeclaration ;
		public List<Affectation> listAffectation ;
}

// Defining Tokens

%token TITREACTEKW

%token TRUE FALSE DOLLAR

%token PLUS MINUS MUL DIV

%token PARENTOPEN PARENTCLOSE BRACEOPEN BRACECLOSE

%token AND OR NOT
%token EGALE INF INFEGALE SUP SUPEGALE

%token ASSIGN

%token SEMICOLON

%token SEPARATOR

%token <String> ID
%token <String> STRING
%token <Integer> INTEGER
%token <Float> FLOAT
%token <String> DEADWORD

//types

%type<expression> montage
%type<affectation> affectation
%type<expression> expression
%type<constante> constante
%type<variable> var
%type<listAffectation> listAffectation
%type<String> defActeTitle
%type<String> deadText
%type<String> declaredVariableName
%type<String> declaredVariableType
%type<String> affectationType
%type<declaration> declaration
%type<listDeclaration> listDeclaration

%type<String> textBloc

// Priority

%left AND OR 
%left NOT
%left EGALE INF INFEGALE SUP SUPEGALE


%left PLUS MINUS
%left DIV MUL
%left ID


%% // Grammar rules section

montage		:	  /*Empty*/																{ Console.WriteLine(" Empty programe "); }
			|	defActeTitle listDeclaration SEPARATOR listAffectation document 		{  montage.nameOfTheMontage=$1; montage.listOfDeclarations=$2; montage.listOfCalculExpressions=$4;  }
			;

defActeTitle	:	TITREACTEKW BRACEOPEN deadText BRACECLOSE		{ $$ = $3; }
				;

deadText		:	DEADWORD						{ $$ = $1; }
				|	ID								{ $$ = $1; }
				|	deadText DEADWORD				{ $$ = $1 + " " + $2; }
				|	deadText ID						{ $$ = $1 + " " + $2; }
				;

listDeclaration :	/*Empty*/						{ $$ = new List<Declaration>(); }
				|   listDeclaration declaration		{ $$=$1; $$.Add($2); }
				;

declaration		:	declaredVariableName  declaredVariableType SEMICOLON											{ $$ = new Declaration($1, $2); montage.IsValideTypeString($2,@2.StartLine, @2.StartColumn); montage.AddSymbole($$); }
				|	declaredVariableName declaredVariableType BRACEOPEN listDeclaration BRACECLOSE SEMICOLON		{ $$ = new DeclarationStruct($1, $2, $4); montage.IsValideTypeString($2,@2.StartLine, @2.StartColumn); montage.AddSymbole($$.GetSymboles()); }
				;

declaredVariableName	:	ID		{ $$ = $1; }
						;



							

listAffectation :	/*Empty*/						{ $$ = new List<Affectation>();  }
				|   listAffectation affectation		{ $$=$1; $$.Add($2);  }
				;

affectation	:		var affectationType ASSIGN expression SEMICOLON				{ $$ = new Affectation($1, $4); montage.CheckAffectationIsValid($4.dataType, $2, $1.name ,@1.StartLine);  montage.AddSymbole($$);  }
			;

affectationType			:	declaredVariableType		{ @$=@1; $$ = $1; }
						| /*Empty*/						{ $$=null; }
						;

declaredVariableType	:	ID		{ @$=@1; $$ = $1.ToUpper(); }
						;

expression  :       expression PLUS expression			{ /*Console.WriteLine("PLUS");*/	$$ = new Expression(ExpressionSymbole.PLUS, $1, $3); }
            |       expression MUL expression			{ /*Console.WriteLine("MUL");*/		$$ = new Expression(ExpressionSymbole.MUL, $1, $3);}
            |       expression DIV expression			{ /*Console.WriteLine("DIV");*/		$$ = new Expression(ExpressionSymbole.DIV, $1, $3); }
            |       expression MINUS expression			{ /*Console.WriteLine("MINUS");*/	$$ = new Expression(ExpressionSymbole.MINUS, $1, $3); }
			|       expression AND expression			{ /*Console.WriteLine("AND");*/		$$ = new Expression(ExpressionSymbole.AND, $1, $3); }
            |       expression OR expression			{ /*Console.WriteLine("OR");*/		$$ = new Expression(ExpressionSymbole.OR, $1, $3); }
            |       NOT expression						{ /*Console.WriteLine("NOT");*/		$$ = new Expression(ExpressionSymbole.NOT, $2); }
            |       expression EGALE expression			{ /*Console.WriteLine("EGALE");*/	$$ = new Expression(ExpressionSymbole.EGALE, $1, $3); }
            |       expression INF expression			{ /*Console.WriteLine("INF");*/		$$ = new Expression(ExpressionSymbole.INF, $1, $3); }
            |       expression INFEGALE expression		{ /*Console.WriteLine("INFEGALE");*/ $$ = new Expression(ExpressionSymbole.INFEGALE, $1, $3); }
            |       expression SUP expression			{ /*Console.WriteLine("SUP");*/		$$ = new Expression(ExpressionSymbole.SUP, $1, $3); }
            |       expression SUPEGALE expression		{ /*Console.WriteLine("SUPEGALE");*/ $$ = new Expression(ExpressionSymbole.SUPEGALE, $1, $3); }
			|		PARENTOPEN expression PARENTCLOSE	{ /*Console.WriteLine("PARENT");*/	$$ = new Expression(ExpressionSymbole.PARENT, $2); }
            |       var									{ /*Console.WriteLine("var :" +$1 );*/ montage.IsInSymboleTable($1.name, @1.StartLine, @1.StartColumn ); $$ = $1; }
            |       constante							{ /*Console.WriteLine("constante");*/  $$ = $1; }
            ;

var     :   ID      { @$ = @1; $$ = new VariableId($1, montage.GetVarTypeString($1)); }
        ;

constante   :   INTEGER		{ @$ = @1; /*Console.WriteLine("int :" + $1 );*/		$$ = new VariableInteger($1);}
			|	FLOAT		{ @$ = @1; /*Console.WriteLine("float :" + $1 );*/		$$ = new VariableFloat($1);}
			|	STRING		{ @$ = @1; /*Console.WriteLine("string :" + $1 );*/		$$ = new VariableString($1);}
            ;

document	: /* Empty */			{ }
			| SEPARATOR listbrick		{}
			;

listbrick	:  /* Empty */			{ Console.WriteLint("Empty Liste of brick"); }
			| listbrick brick		{ Console.WriteLine("Brick"); }
			;

brick		: textBloc				{ Console.WriteLine("Texte bloc : " + $1); }
			;

textBloc	: DEADWORD				{ $$ = $1; }
			| ID					{ $$ = $1; }
			| textBloc DEADWORD		{ $$ = $1; $$ += $2; }
			| textBloc ID			{ $$ = $1; $$ += $2; }

%%
// Error: Syntax error, unexpected %%
// ----------------------------------

// No argument CTOR. By deafult Parser's ctor requires scanner as param.
public Parser(Scanner scn) : base(scn) {}

// ==========================================================================

